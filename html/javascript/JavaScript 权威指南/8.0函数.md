# Function

- 调用函数，传入实参。在函数定义形参()。
- 函数在调用时，有一个特殊的值。本次调用的上下文。--this
- 函数挂载在对象上，就成为对象的属性，也称对象的方法。 调用对象的方法。this 值就是这个对象。

## 函数调用

- 作为函数(独立函数调用)
- 作为方法(隐式绑定)
- 作为构造函数(构造调用)
- 使用 call、apply 和 bind 方法调用。（显式绑定）

### 作为函数

- 调用上下文在非严格模式下 this 值是 window。严格模式下是 undefined。

> 区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

#### IIFE

- IIFE:代表立即执行函数表达式（ImmediatelyInvoked Function Expression）
- IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。

```
var a = 2;
(function( global ){
    var a =3;
    console.log( a );
    console.log( this.a )
    console.log( global.a)
})(window)
```

### 方法调用

- 调用上下文：使用方法调用函数，this 的值就是调用的对象。
- 方法调用隐式丢失 this
  - 指向丢失 this
  - 回调函数丢失 this
    - setTimeout

```
function foo(){
    return this.a
}

var obj = {
    a: 200,
    foo : foo
}

var bq = obj.foo   // bq是obj.foo的一个引用，但是实际上，它引用的是foo函数本身。所有this指向windows or undefined

bq()

<!--  -->

function foo(){
    return this.a
}

var obj = {
    a : 100,
    foo : foo
}

funtion tofoo(fn){
    fn()
}

tofoo(obj.foo)  //参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值


```

#### this

- 关键字 this 没有作用域的限制，嵌套函数不会从调用它的函数中继承 this。
- 如果嵌套函数作为方法返回，那么 this 值指向调用的对象。
- 如果嵌套函数作为函数调用，那么 this 值指向 window（严格模式下 undefined）。
- this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。
- 内置函数 setTimeout()...会丢失 this 指向。
- 使用`方法调用函数`只有最顶层或者说最后一层会影响调用位置。--《你不知道的 javascript》

```
function foo() {
console.log( this.a );
}
var obj1 = {
    a: 2,
    obj2: obj2
};
var obj2 = {
    a: 42,
    foo: foo
};

obj1.obj2.foo();
```

##### this 绑定

1. 由 new 调用？绑定到新创建的对象。
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。

### 构造函数调用

- 函数或方法在调用前有`new`关键字，它就是构造函数调用。
- 构造函数调用，在实参处理、调用上下文和返回值都不同。

#### 构造函数

- 包括内置对象函数（比如 Number(..)）在内的所有函数都可以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区别：实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。
- 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。
  - 创建（或者说构造）一个全新的对象。 var obj = new base();
  - 这个新对象会被执行[[原型]]连接。 var obj = {};
  - 这个新对象会绑定到函数调用的 this。 obj.**proto** = base.prototype;
  - 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 base.call(obj);

#### 函数调用的优先级

1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。

```
var bar = new Foo()
```

2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。

```
fn.call(obj)
```

3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。

```
var bar = obj.foo()
```

4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。

```
foo()
```

---

- callee ： 正在执行的函数。
- caller ： 调用正在执行的函数。

### 闭包

- JavaScript 采用语法作用域，函数执行依赖变量作用域。
- 变量作用域在定义的决定的，不是在调用时决定的。
- 变量作用域+函数作用域 --> 当前作用域。
- 函数通过作用域相互关联起来，函数体内的变量都也可保存在函数作用域中。 --> 闭包。

- 从技术角度上将，所有的函数都是对象，都关联作用域， 都是闭包。

#### 函数作用域

- 函数内所有定义的变量在函数体都是可见的。
- 也就是说，可以在未定义之前使用变量 --> 变量提示。

- 函数里声明的所有变量都会提升（变量不包括赋值的。）

#### 变量作用域(词法作用域)

- 全局变量局有全局作用域。
- 函数内声明的变量(局部变量)，只在函数体内可见。
- 函数参数也是局部变量。
