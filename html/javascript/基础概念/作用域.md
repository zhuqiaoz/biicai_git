# 作用域

- LHR --赋值操作的左侧
- RHR --赋值操作的右侧

## 词法作用域

- 词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。
- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

## 函数作用域

- 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。
- 每一个函数(私有)都保持单一的功能性。对应最小暴露原则。
- 避免变量名冲突、变量意外覆盖。

- let 暂存死区 在函数作用域中(块开始)到定义 LET 前，使用 let 定义的变量。叫暂时死区(与变量提升相反)

- 函数声明与函数表达式的区别： 看`function`关键字出现的位置，如果出现在第一个词那么就是`函数声明`。

### 作用域嵌套

- 作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个作用域。
- 当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域(全局作用域)

* 嵌套作用域链的规则很简单： - 引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。

## 函数声明和变量声明 函数优先

- 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。

## this

- this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

- 函数调用时，创建活动记录就是`全局上下文`
- 这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。

* 任何声明在某个作用域内的变量，都将附属于这个作用域。
