## 前端性能优化
+ 减少HTTP请求
    - CSS/JS 合并压缩打包
    - 图标使用ICON或者雪碧图
    - 减少图片体积使用新图片格式webp或者base64格式图片
+ 减少静态资源的体积
    - 压缩CSS/JS、图片的体积
    - 编写高效率的CSS
    - 服务段开启gzip压缩
+ 使用缓存
    - 将网站的一些静态资源，存放在浏览器中。
    - 设置Http Header里面缓存相关的字段，做进一步的优化。
        <img src="./http/img/header.jpg" title="HTTP Header exprss">
    - 可以设置etag、maxAge等，进一步会有200缓存和304缓存的区别：
```
200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存；而 304 Not Modified 是浏览器和服务器多确认了一次缓存的有效性，然后再使用的缓存。
```
+ 减少DNS查找时间
    - DNS用于映射主机名和IP地址，一般一次解析需要20～120毫秒。浏览器会首先根据页面的主机名进行域名解析，在有ISP返回结果之前页面不会加载任何内容，所以减少DNS查找可以有效降低等待时间。为达到更高的性能，DNS解析通常被多级别地缓存，如由ISP或局域网维护的caching server，本地机器操作系统的缓存（如windows上的DNS Client Service），浏览器。IE的缺省DNS缓存时间为30分钟，Firefox的缺省缓冲时间是1分钟。 我们能做的是尽量减少一个页面的主机名，但要在浏览器最大并行下载数跟dns查找之间做权衡。根据雅虎的研究，最好将主机名控制在2-4个内。
+ CDN加速
    - CDN 的本质也属于缓存，内容分发网络，把数据缓存在里用户近的地方，使用户尽快的获取数据。CDN 通常是部署在网络运营商的机房，这些运营商为用户提供网络服务，因此用户请求的路由会优先到达 CDN 服务器，如果存在请求的资源的话，就直接返回，以最短路径返回响应，提高了用户访问速度，同时还能够为中心机房减轻压力。
    - CDN 一般用来缓存静态资源，如css，Script脚本，静态页面，图片等，这些内容修改频率很低但是访问请求频率很高，因此放在 CDN 上能够很好的改善访问速度
+ 减少重定向
    - 重定向是指将一个URL重新路由到另一个URL。浏览器会自动重定向请求到Location指定的URL上，也就说把之前的过程又重复一遍才能请求到真正的资源，会极大地降低用户体验。

---
<!-- http://www.w3cplus.com/performance/prefetching-preloading-prebrowsing.html -->
+ DNS 预解析 `DNS-Prefetch`
    - 通过 DNS 预解析来告诉浏览器未来我们可能从某个特定的 URL 获取资源，当浏览器真正使用到该域中的某个资源时就可以尽快地完成 DNS 解析。
```
<link rel="dns-prefetch" href="//example.com">著作权归作者所有。
```
+ 预连接 `Preconnect`
    - 与 DNS 预解析类似，`preconnect` 不仅完成 `DNS` 预解析，同时还将进行 `TCP` 握手和建立传输层协议。可以这样使用：
```
<link rel="Preconnect" href="//example.com">
```
+ 预获取 `Prefetching`
    - 如果我们确定某个资源将来一定会被使用到，我们可以让浏览器预先请求该资源并放入浏览器缓存中。例如，一个图片和脚本或任何可以被浏览器缓存的资源：
```
<link rel="prefetch" href="image.png">
```
+ 预渲染 `Prerender`
    - 这是一个核武器，因为 prerender 可以预先加载文档的所有资源：
```
<link rel="prerender" href="http://example.com">
```
+ `Subresources`
    - 这是另一个预获取方式，这种方式指定的预获取资源具有最高的优先级，在所有 `prefetch` 项之前进行：
```
<link rel="subresource" href="styles.css">
```
    - 所以，如果资源是当前页面必须的，或者资源需要尽快可用，那么最好使用 subresource 而不是 prefetch。

### 防抖节流
1. 防抖
    > 触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间.
    
    > 每次触发事件时都取消之前的延时调用方法
2. 节流

    > 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

    > 每次触发事件时都判断当前是否有等待执行的延时函数